<!doctype html>
<html lang="de">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1, width=device-width" />
    <title>Naumburg Interaktiv</title>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="">
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <style>
        :root {
            --panel-bg: rgba(255, 255, 255, 0.94);
            --panel-border: rgba(15, 23, 42, 0.16);
            --panel-radius: 18px;
            --shadow-soft: 0 18px 36px rgba(15, 23, 42, 0.18);
            --text-muted: #64748b;
            --accent: #0a7cff;
            --bg-soft: #f8fafc;
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            font-family: "Inter", "Segoe UI", system-ui, sans-serif;
            color: #111827;
            background: #e2e8f0;
            overscroll-behavior: none;
        }

        #map {
            height: 100%;
            width: 100%;
        }

        #sidebar {
            position: absolute;
            inset: 0 auto 0 0;
            width: 320px;
            padding: 24px 24px 32px;
            background: var(--panel-bg);
            border-right: 1px solid rgba(15, 23, 42, 0.08);
            box-shadow: 12px 0 32px rgba(15, 23, 42, 0.14);
            display: flex;
            flex-direction: column;
            gap: 24px;
            z-index: 1200;
            transition: transform 0.28s ease, box-shadow 0.28s ease;
        }

        #sidebar.collapsed {
            transform: translateX(calc(-100% + 52px));
            box-shadow: none;
        }

        #sidebarToggle {
            position: absolute;
            top: 20px;
            right: 16px;
            width: 32px;
            height: 32px;
            border-radius: 10px;
            border: 1px solid var(--panel-border);
            background: #fff;
            font-weight: 700;
            cursor: pointer;
            display: grid;
            place-items: center;
            box-shadow: 0 6px 14px rgba(15, 23, 42, 0.12);
        }

        #sidebar.collapsed #sidebarToggle {
            right: -40px;
        }

        #sidebar.collapsed .sidebar-inner {
            opacity: 0;
            pointer-events: none;
            visibility: hidden;
        }

        .sidebar-inner {
            display: flex;
            flex-direction: column;
            gap: 24px;
            transition: opacity 0.18s ease;
        }

        .sidebar-title {
            font-size: 22px;
            font-weight: 700;
            margin: 0;
            letter-spacing: -0.01em;
        }

        .group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .group-label {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 16px;
            font-weight: 600;
        }

        .group-label input {
            width: 18px;
            height: 18px;
        }

        .item-list {
            margin: 0;
            padding: 0;
            list-style: none;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .item {
            background: #fff;
            border: 1px solid rgba(15, 23, 42, 0.08);
            border-radius: 14px;
            padding: 10px 12px;
            box-shadow: 0 8px 20px rgba(15, 23, 42, 0.08);
            display: flex;
            flex-direction: column;
            gap: 8px;
            transition: border-color 0.15s ease, transform 0.15s ease;
        }

        .item.is-active {
            border-color: var(--accent);
        }

        .item.is-disabled {
            opacity: 0.45;
        }

        .item.is-focused {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }

        .item-header {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .item-toggle {
            width: 18px;
            height: 18px;
        }

        .item-title {
            flex: 1;
            padding: 4px 0;
            background: none;
            border: none;
            text-align: left;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
        }

        .item-title:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }

        .drag-handle {
            width: 18px;
            height: 18px;
            display: grid;
            place-items: center;
            font-size: 16px;
            color: var(--text-muted);
            cursor: grab;
            user-select: none;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        .item-slider {
            display: none;
            padding-top: 4px;
            border-top: 1px solid rgba(15, 23, 42, 0.08);
        }

        .item.slider-open .item-slider {
            display: block;
        }

        .slider-meta {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .slider-value {
            font-variant-numeric: tabular-nums;
        }

        .item-slider input[type="range"] {
            width: 100%;
        }

        .floating-panel {
            position: absolute;
            background: var(--panel-bg);
            border-radius: var(--panel-radius);
            border: 1px solid var(--panel-border);
            box-shadow: var(--shadow-soft);
            padding: 18px 20px;
            font-size: 14px;
            max-width: min(420px, 34vw);
            z-index: 1200;
        }

        #tutorial {
            top: 24px;
            right: 24px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        #tutorial.hidden {
            display: none;
        }

        #tutorialBadge {
            position: absolute;
            top: 24px;
            right: 24px;
            width: 40px;
            height: 40px;
            border-radius: 999px;
            border: 1px solid var(--panel-border);
            background: #fff;
            box-shadow: var(--shadow-soft);
            font-weight: 700;
            cursor: pointer;
            display: none;
            place-items: center;
            z-index: 1200;
        }

        #tutorialBadge.is-visible {
            display: grid;
        }

        .panel-header {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .panel-header h3 {
            margin: 0;
            font-size: 18px;
        }

        .panel-actions {
            margin-left: auto;
            display: flex;
            gap: 8px;
        }

        .panel-actions button {
            width: 28px;
            height: 28px;
            border-radius: 8px;
            border: 1px solid rgba(15, 23, 42, 0.12);
            background: #fff;
            cursor: pointer;
            font-weight: 600;
        }

        .tutorial-body {
            font-size: 14px;
            line-height: 1.6;
        }

        .tutorial-meta {
            font-size: 12px;
            color: var(--text-muted);
            margin-left: auto;
        }

        #rightDock {
            position: absolute;
            right: 24px;
            bottom: 24px;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 16px;
            width: min(420px, calc(100vw - 64px));
            z-index: 1200;
        }

        #poiDetail,
        #timeControl {
            position: relative;
            width: 100%;
            max-width: min(420px, calc(100vw - 64px));
        }

        #poiDetail.hidden {
            display: none;
        }

        #poiDetailBody p {
            margin-top: 0;
            margin-bottom: 10px;
            line-height: 1.5;
        }

        #poiDetailBody img {
            max-width: 100%;
            border-radius: 12px;
            display: block;
            margin: 10px 0;
        }

        #poiDetailTags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 10px;
        }

        .chip {
            background: var(--bg-soft);
            border-radius: 999px;
            padding: 4px 10px;
            font-size: 12px;
            font-weight: 500;
        }

        #timeControl header {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .time-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        #eraLabels {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: 6px;
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 8px;
        }

        #eraLabels span {
            text-align: center;
            padding: 4px 6px;
            border-radius: 6px;
            background: rgba(148, 163, 184, 0.15);
        }

        input[type="range"] {
            accent-color: var(--accent);
        }

        a {
            color: var(--accent);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        @media (max-width: 960px) {
            #sidebar {
                width: 280px;
            }

            #sidebar.collapsed {
                transform: translateX(calc(-100% + 48px));
            }

            .floating-panel {
                max-width: 92vw;
            }

            #tutorial {
                right: 16px;
                left: 16px;
            }

            #rightDock {
                right: 16px;
                left: 16px;
                align-items: stretch;
                width: calc(100% - 32px);
            }

            #timeControl,
            #poiDetail {
                width: 100%;
                max-width: 100%;
            }
        }
    </style>
</head>

<body>
    <div id="map"></div>

    <aside id="sidebar" aria-label="Karten-Steuerung">
        <button id="sidebarToggle" type="button" aria-expanded="true" aria-label="Menü einklappen">
            &laquo;
        </button>

        <div class="sidebar-inner">
            <h1 class="sidebar-title">Karten-Steuerung</h1>

            <section class="group" aria-label="Historische Karten">
                <label class="group-label" for="toggleAllOverlays">
                    <input id="toggleAllOverlays" type="checkbox" checked>
                    Historische Karten
                </label>
                <ul id="overlayList" class="item-list"></ul>
            </section>

            <section class="group" aria-label="Historische POIs">
                <label class="group-label" for="toggleAllPois">
                    <input id="toggleAllPois" type="checkbox" checked>
                    Historische POIs
                </label>
                <ul id="poiList" class="item-list"></ul>
            </section>
        </div>
    </aside>

    <aside id="tutorial" class="floating-panel" aria-live="polite">
        <div class="panel-header">
            <h3 id="tutorialTitle">Willkommen</h3>
            <div class="panel-actions">
                <button id="tutorialPrev" type="button" title="Zurück">&#8249;</button>
                <button id="tutorialNext" type="button" title="Weiter">&#8250;</button>
                <button id="tutorialClose" type="button" title="Tutorial schließen">&times;</button>
            </div>
        </div>
        <div id="tutorialContent" class="tutorial-body"></div>
        <div id="tutorialMeta" class="tutorial-meta"></div>
    </aside>

    <button id="tutorialBadge" type="button" title="Tutorial anzeigen">?</button>

    <div id="rightDock">
        <aside id="poiDetail" class="floating-panel hidden" aria-live="polite">
            <div class="panel-header">
                <h3 id="poiDetailTitle">POI</h3>
                <div class="panel-actions">
                    <button id="poiDetailClose" type="button" title="Details schließen">&times;</button>
                </div>
            </div>
            <div id="poiDetailBody"></div>
            <div id="poiDetailTags"></div>
        </aside>

        <section id="timeControl" class="floating-panel" aria-label="Zeiteinstellung">
            <header>Zeiteinstellung</header>
            <div class="time-meta">
                <span id="eraLabel">Epoche</span>
                <span id="eraCounter">1/1</span>
            </div>
            <input id="era" type="range" min="0" max="0" step="1" value="0" aria-label="Zeitleiste">
            <div id="eraLabels"></div>
        </section>
    </div>

    <script>
        const DEFAULT_ERAS = ["Frühmittelalter", "Hochmittelalter", "Spätmittelalter", "Frühe Neuzeit", "Moderne", "Postmoderne"];

        const DATA = {
            config: 'assets/data/config.json',
            pois: 'assets/data/pois.json',
            polygons: 'assets/data/polygons.geojson',
            overlays: 'assets/data/overlays.json',
            cardsIdx: 'assets/infocards/index.json',
            cardsDir: 'assets/infocards/'
        };

        let ERAS = DEFAULT_ERAS.slice(0);
        let map;

        const state = {
            currentEraIndex: 0,
            overlays: [],
            pois: [],
            polygonsData: null,
            polygonLayer: null,
            infoCards: [],
            tutorialIndex: 0,
            tutorialVisible: true,
            activePoiId: null
        };

        const elements = {};
        const DEFAULT_OVERLAY_IMAGE = 'assets/images/000.png';
        const DEFAULT_OVERLAY_DELTA = {
            lat: 0.018,
            lon: 0.028
        };

        fixLeafletIconPath();

        (async function init() {
            elements.sidebar = document.getElementById('sidebar');
            elements.sidebarToggle = document.getElementById('sidebarToggle');
            elements.overlayList = document.getElementById('overlayList');
            elements.poiList = document.getElementById('poiList');
            elements.overlayGroupToggle = document.getElementById('toggleAllOverlays');
            elements.poiGroupToggle = document.getElementById('toggleAllPois');
            elements.timeSlider = document.getElementById('era');
            elements.eraLabel = document.getElementById('eraLabel');
            elements.eraCounter = document.getElementById('eraCounter');
            elements.eraLabels = document.getElementById('eraLabels');
            elements.tutorial = document.getElementById('tutorial');
            elements.tutorialTitle = document.getElementById('tutorialTitle');
            elements.tutorialContent = document.getElementById('tutorialContent');
            elements.tutorialMeta = document.getElementById('tutorialMeta');
            elements.tutorialPrev = document.getElementById('tutorialPrev');
            elements.tutorialNext = document.getElementById('tutorialNext');
            elements.tutorialClose = document.getElementById('tutorialClose');
            elements.tutorialBadge = document.getElementById('tutorialBadge');
            elements.poiDetail = document.getElementById('poiDetail');
            elements.poiDetailTitle = document.getElementById('poiDetailTitle');
            elements.poiDetailBody = document.getElementById('poiDetailBody');
            elements.poiDetailTags = document.getElementById('poiDetailTags');
            elements.poiDetailClose = document.getElementById('poiDetailClose');

            const cfg = await fetchJSON(DATA.config, {
                start: {
                    lat: 51.1517,
                    lon: 11.8096,
                    zoom: 13
                },
                eras: DEFAULT_ERAS
            });

            ERAS = sanitizeEraList(Array.isArray(cfg.eras) && cfg.eras.length ? cfg.eras : DEFAULT_ERAS.slice(0));

            initMap(cfg);

            const [poisData, polygonsData, overlaysData, infoCards] = await Promise.all([
                fetchJSON(DATA.pois, { type: "FeatureCollection", features: [] }),
                fetchJSON(DATA.polygons, { type: "FeatureCollection", features: [] }),
                fetchJSON(DATA.overlays, []),
                loadInfoCards()
            ]);

            state.infoCards = infoCards;
            state.polygonsData = polygonsData;

            initOverlays(overlaysData);
            initPois(poisData);
            refreshPolygons();
            buildEraLabels();
            setupSidebar();
            setupTimeControl(cfg);
            setupTutorial();
            applyEraFilter();

            if (Array.isArray(cfg.fitBounds) && cfg.fitBounds.length === 2) {
                map.fitBounds(cfg.fitBounds);
            }
        })();

        function initMap(cfg) {
            map = L.map('map', {
                center: [cfg.start.lat, cfg.start.lon],
                zoom: cfg.start.zoom,
                preferCanvas: true
            });

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 20,
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>-Mitwirkende'
            }).addTo(map);

            const url = new URL(location.href);
            const pLat = parseFloat(url.searchParams.get('lat'));
            const pLon = parseFloat(url.searchParams.get('lon'));
            const pZ = parseInt(url.searchParams.get('z'), 10);
            if (isFinite(pLat) && isFinite(pLon)) {
                map.setView([pLat, pLon], isFinite(pZ) ? pZ : map.getZoom());
            }
        }

        function initOverlays(overlaysData) {
            state.overlays = [];
            elements.overlayList.innerHTML = '';

            const overlaysList = (Array.isArray(overlaysData) && overlaysData.length)
                ? overlaysData.map(function (entry) {
                    const copy = Object.assign({}, entry);
                    if (Array.isArray(entry.bounds)) {
                        copy.bounds = entry.bounds.map(function (pair) {
                            return Array.isArray(pair) ? pair.slice(0) : pair;
                        });
                    } else if (entry.corners && typeof entry.corners === 'object') {
                        copy.corners = JSON.parse(JSON.stringify(entry.corners));
                    }
                    return copy;
                })
                : [createDefaultOverlayConfig()];

            overlaysList.forEach(function (ov, index) {
                if (typeof ov.era === 'string') {
                    ov.era = [ov.era];
                }
                if (Array.isArray(ov.era)) {
                    ov.era = ov.era.map(function (name) {
                        return sanitizeEraLabel(name, String(name));
                    });
                }
                const id = ov.id || `overlay-${index}`;
                const title = ov.title || `Karte ${index + 1}`;
                const opacity = clamp(typeof ov.opacity === 'number' ? ov.opacity : 0.6, 0, 1);
                const bounds = toBounds(ov);
                const rotation = typeof ov.rotation === 'number' ? ov.rotation : 0;
                const pivot = Array.isArray(ov.pivot) && ov.pivot.length === 2 ? ov.pivot : null;
                if (!ov.url) {
                    console.warn('Overlay ohne URL wurde übergangen:', ov);
                    return;
                }
                const layer = createRotatedImageOverlay(ov.url, bounds, {
                    opacity: opacity,
                    interactive: false,
                    crossOrigin: 'anonymous',
                    pivot: pivot
                }, rotation);

                const entry = createListEntry({
                    id,
                    title,
                    initialOpacity: opacity,
                    onToggle: function (checked) {
                        record.desired = checked;
                        toggleOverlay(record);
                    },
                    onOpacityChange: function (value) {
                        record.opacity = value;
                        if (map.hasLayer(record.layer)) {
                            record.layer.setOpacity(value);
                        }
                    }
                });

                const record = {
                    id,
                    data: ov,
                    layer,
                    opacity,
                    desired: true,
                    allowed: true,
                    element: entry.li,
                    checkbox: entry.checkbox,
                    slider: entry.slider
                };
                if (ov.fitOnActivate) {
                    record.fitOnActivate = true;
                }

                entry.checkbox.checked = true;
                entry.slider.value = opacity;
                entry.slider.disabled = false;

                state.overlays.push(record);
                elements.overlayList.appendChild(entry.li);
            });

            createSortable(elements.overlayList, function (order) {
                reorderRecords('overlays', order);
            });

            updateOverlayOrder();
        }

        function initPois(poiData) {
            state.pois = [];
            elements.poiList.innerHTML = '';

            const collection = Array.isArray(poiData.features) ? poiData.features : [];

            collection.forEach(function (feature, index) {
                if (!feature || !feature.geometry || feature.geometry.type !== 'Point') return;
                const coords = feature.geometry.coordinates;
                if (!Array.isArray(coords) || coords.length < 2) return;
                const id = feature.id || feature.properties?.id || `poi-${index}`;
                const title = feature.properties?.title || `POI ${index + 1}`;
                const marker = L.marker([coords[1], coords[0]], {
                    title: title
                });
                marker.on('click', function () {
                    showFeatureInfo(feature);
                });

                const entry = createListEntry({
                    id,
                    title,
                    initialOpacity: 1,
                    onToggle: function (checked) {
                        record.desired = checked;
                        togglePoi(record);
                    },
                    onOpacityChange: function (value) {
                        record.opacity = value;
                        if (map.hasLayer(record.marker)) {
                            record.marker.setOpacity(value);
                        }
                    }
                });

                const record = {
                    id,
                    feature,
                    marker,
                    opacity: 1,
                    desired: true,
                    allowed: true,
                    element: entry.li,
                    checkbox: entry.checkbox,
                    slider: entry.slider
                };

                entry.checkbox.checked = true;
                entry.slider.disabled = false;

                state.pois.push(record);
                elements.poiList.appendChild(entry.li);
            });

            createSortable(elements.poiList, function (order) {
                reorderRecords('pois', order);
            });

            updatePoiOrder();
        }

        function setupSidebar() {
            elements.sidebarToggle.addEventListener('click', function () {
                const collapsed = elements.sidebar.classList.toggle('collapsed');
                elements.sidebarToggle.setAttribute('aria-expanded', String(!collapsed));
                elements.sidebarToggle.innerHTML = collapsed ? '&raquo;' : '&laquo;';
            });

            elements.overlayGroupToggle.addEventListener('change', function (event) {
                const desired = event.target.checked;
                state.overlays.forEach(function (record) {
                    record.desired = desired;
                    toggleOverlay(record, { skipSync: true });
                });
                syncGroupState('overlays');
                applyEraFilter();
            });

            elements.poiGroupToggle.addEventListener('change', function (event) {
                const desired = event.target.checked;
                state.pois.forEach(function (record) {
                    record.desired = desired;
                    togglePoi(record, { skipSync: true });
                });
                syncGroupState('pois');
                applyEraFilter();
            });

            elements.poiDetailClose.addEventListener('click', hidePoiDetail);
        }

        function setupTimeControl(cfg) {
            const url = new URL(location.href);
            const paramEra = url.searchParams.get('era');
            let startIdx = 0;
            if (paramEra && ERAS.includes(paramEra)) {
                startIdx = ERAS.indexOf(paramEra);
            } else if (Number.isInteger(cfg.startEraIndex) && cfg.startEraIndex >= 0 && cfg.startEraIndex < ERAS.length) {
                startIdx = cfg.startEraIndex;
            }

            state.currentEraIndex = startIdx;

            elements.timeSlider.max = ERAS.length - 1;
            elements.timeSlider.value = String(state.currentEraIndex);
            updateEraUI();

            elements.timeSlider.addEventListener('input', function (event) {
                state.currentEraIndex = parseInt(event.target.value, 10);
                updateEraUI();
                applyEraFilter();
            });
        }

        function setupTutorial() {
            renderTutorial();

            elements.tutorialPrev.addEventListener('click', function () {
                if (!state.infoCards.length) return;
                state.tutorialIndex = (state.tutorialIndex - 1 + state.infoCards.length) % state.infoCards.length;
                renderTutorial();
            });

            elements.tutorialNext.addEventListener('click', function () {
                if (!state.infoCards.length) return;
                state.tutorialIndex = (state.tutorialIndex + 1) % state.infoCards.length;
                renderTutorial();
            });

            elements.tutorialClose.addEventListener('click', function () {
                hideTutorial();
            });

            elements.tutorialBadge.addEventListener('click', function () {
                showTutorial();
            });

            window.addEventListener('keydown', function (event) {
                if (!state.tutorialVisible) return;
                if (state.infoCards.length === 0) return;
                if (event.key === 'ArrowLeft') {
                    state.tutorialIndex = (state.tutorialIndex - 1 + state.infoCards.length) % state.infoCards.length;
                    renderTutorial();
                }
                if (event.key === 'ArrowRight') {
                    state.tutorialIndex = (state.tutorialIndex + 1) % state.infoCards.length;
                    renderTutorial();
                }
                if (event.key === 'Escape') {
                    hideTutorial();
                }
            });
        }

        function applyEraFilter() {
            const overlaysGroupChecked = elements.overlayGroupToggle ? elements.overlayGroupToggle.checked : false;
            const poisGroupChecked = elements.poiGroupToggle ? elements.poiGroupToggle.checked : false;

            state.overlays.forEach(function (record) {
                const allowed = overlaysGroupChecked && filterByEra(record.data);
                updateOverlayAllowed(record, allowed);
            });

            state.pois.forEach(function (record) {
                const allowed = poisGroupChecked && filterByEra(record.feature);
                updatePoiAllowed(record, allowed);
            });

            refreshPolygons();
            syncGroupState('overlays');
            syncGroupState('pois');
            updateOverlayOrder();
            updatePoiOrder();
        }

        function refreshPolygons() {
            if (state.polygonLayer) {
                state.polygonLayer.remove();
                state.polygonLayer = null;
            }
            if (!state.polygonsData) return;

            state.polygonLayer = L.geoJSON(state.polygonsData, {
                filter: function (feature) {
                    return filterByEra(feature);
                },
                style: function (feature) {
                    const props = feature?.properties || {};
                    return {
                        color: props.stroke || '#0a7cff',
                        weight: Number(props['stroke-width'] ?? 2),
                        opacity: Number(props['stroke-opacity'] ?? 0.9),
                        fillColor: props.fill || '#0a7cff',
                        fillOpacity: Number(props['fill-opacity'] ?? 0.15)
                    };
                },
                onEachFeature: function (feature, layer) {
                    layer.on('click', function () {
                        showFeatureInfo(feature);
                    });
                }
            });

            state.polygonLayer.addTo(map);
        }

        function buildEraLabels() {
            elements.eraLabels.innerHTML = '';
            ERAS.forEach(function (name, index) {
                const span = document.createElement('span');
                span.textContent = name;
                span.dataset.index = String(index);
                elements.eraLabels.appendChild(span);
            });
        }

        function updateEraUI() {
            const currentName = ERAS[state.currentEraIndex] || '';
            elements.eraLabel.textContent = 'Epoche · ' + currentName;
            elements.eraCounter.textContent = `${state.currentEraIndex + 1} / ${ERAS.length}`;

            Array.from(elements.eraLabels.children).forEach(function (child, index) {
                child.style.background = index === state.currentEraIndex ? 'rgba(10, 124, 255, 0.18)' : 'rgba(148, 163, 184, 0.15)';
                child.style.color = index === state.currentEraIndex ? '#0f172a' : 'var(--text-muted)';
                child.style.fontWeight = index === state.currentEraIndex ? '600' : '500';
            });
        }

        function toggleOverlay(record, options) {
            const opts = options || {};
            const shouldShow = record.desired && record.allowed;

            record.checkbox.checked = record.allowed ? record.desired : false;
            record.checkbox.disabled = !record.allowed;
            record.slider.disabled = !record.allowed;
            record.element.classList.toggle('is-active', shouldShow);

            if (shouldShow) {
                record.layer.setOpacity(record.opacity);
                const wasVisible = map.hasLayer(record.layer);
                if (!wasVisible) {
                    record.layer.addTo(map);
                    if (record.fitOnActivate && typeof record.layer.getBounds === 'function') {
                        map.fitBounds(record.layer.getBounds());
                    }
                }
            } else if (map.hasLayer(record.layer)) {
                map.removeLayer(record.layer);
            }

            if (!opts.skipSync) {
                syncGroupState('overlays');
            }

            updateOverlayOrder();
        }

        function togglePoi(record, options) {
            const opts = options || {};
            const shouldShow = record.desired && record.allowed;

            record.checkbox.checked = record.allowed ? record.desired : false;
            record.checkbox.disabled = !record.allowed;
            record.slider.disabled = !record.allowed;
            record.element.classList.toggle('is-active', shouldShow);

            if (shouldShow) {
                record.marker.setOpacity(record.opacity);
                if (!map.hasLayer(record.marker)) {
                    record.marker.addTo(map);
                }
            } else if (map.hasLayer(record.marker)) {
                map.removeLayer(record.marker);
            }

            if (!opts.skipSync) {
                syncGroupState('pois');
            }

            if (!shouldShow && state.activePoiId === record.id) {
                hidePoiDetail();
            }

            updatePoiOrder();
        }

        function updateOverlayAllowed(record, allowed) {
            record.allowed = allowed;
            record.element.classList.toggle('is-disabled', !allowed);
            if (!allowed) {
                record.element.classList.remove('slider-open');
            }
            record.element.hidden = !allowed;
            toggleOverlay(record, { skipSync: true });
        }

        function updatePoiAllowed(record, allowed) {
            record.allowed = allowed;
            record.element.classList.toggle('is-disabled', !allowed);
            if (!allowed) {
                record.element.classList.remove('slider-open');
            }
            record.element.hidden = !allowed;
            togglePoi(record, { skipSync: true });
        }

        function syncGroupState(type) {
            const records = type === 'overlays' ? state.overlays : state.pois;
            const checkbox = type === 'overlays' ? elements.overlayGroupToggle : elements.poiGroupToggle;
            if (!checkbox) return;

            if (!records.length) {
                checkbox.checked = false;
                checkbox.indeterminate = false;
                checkbox.disabled = true;
                return;
            }

            const enabledRecords = records.filter(function (record) {
                return record.allowed;
            });
            const reference = enabledRecords.length ? enabledRecords : records;
            const activeCount = reference.filter(function (record) {
                return record.desired;
            }).length;

            checkbox.disabled = false;

            if (activeCount === 0) {
                checkbox.checked = false;
                checkbox.indeterminate = false;
            } else if (activeCount === reference.length) {
                checkbox.checked = true;
                checkbox.indeterminate = false;
            } else {
                checkbox.checked = false;
                checkbox.indeterminate = true;
            }
        }

        function updateOverlayOrder() {
            const total = state.overlays.length;
            state.overlays.forEach(function (record, index) {
                if (record.layer && record.layer.setZIndex) {
                    const order = total - index;
                    record.layer.setZIndex(1000 + order);
                }
            });
        }

        function updatePoiOrder() {
            const total = state.pois.length;
            state.pois.forEach(function (record, index) {
                const order = total - index;
                if (record.marker && record.marker.setZIndexOffset) {
                    record.marker.setZIndexOffset(order * 1000);
                }
            });
        }

        function reorderRecords(type, order) {
            const records = type === 'overlays' ? state.overlays : state.pois;
            const mapIndex = {};
            order.forEach(function (id, index) {
                mapIndex[id] = index;
            });
            records.sort(function (a, b) {
                const ai = mapIndex[a.id];
                const bi = mapIndex[b.id];
                return ai - bi;
            });

            if (type === 'overlays') {
                updateOverlayOrder();
            } else {
                updatePoiOrder();
            }
        }

        function createListEntry(options) {
            const { id, title, initialOpacity, onToggle, onOpacityChange } = options;
            const li = document.createElement('li');
            li.className = 'item';
            li.dataset.id = id;

            const header = document.createElement('div');
            header.className = 'item-header';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'item-toggle';
            checkbox.setAttribute('aria-label', `${title} einblenden`);

            const titleBtn = document.createElement('button');
            titleBtn.type = 'button';
            titleBtn.className = 'item-title';
            titleBtn.textContent = title;
            titleBtn.setAttribute('aria-expanded', 'false');

            const handle = document.createElement('span');
            handle.className = 'drag-handle';
            handle.setAttribute('draggable', 'true');
            handle.setAttribute('title', 'Zum Sortieren ziehen');
            handle.textContent = '⋮⋮';

            header.appendChild(checkbox);
            header.appendChild(titleBtn);
            header.appendChild(handle);
            li.appendChild(header);

            const sliderWrap = document.createElement('div');
            sliderWrap.className = 'item-slider';

            const sliderMeta = document.createElement('div');
            sliderMeta.className = 'slider-meta';

            const sliderLabel = document.createElement('span');
            sliderLabel.textContent = 'Deckkraft';

            const value = document.createElement('span');
            value.className = 'slider-value';
            value.textContent = formatPercent(initialOpacity);

            sliderMeta.appendChild(sliderLabel);
            sliderMeta.appendChild(value);

            const slider = document.createElement('input');
            slider.type = 'range';
            slider.min = '0';
            slider.max = '1';
            slider.step = '0.05';
            slider.value = String(initialOpacity);
            slider.setAttribute('aria-label', `${title} Deckkraft`);

            sliderWrap.appendChild(sliderMeta);
            sliderWrap.appendChild(slider);
            li.appendChild(sliderWrap);

            titleBtn.addEventListener('click', function () {
                const open = li.classList.toggle('slider-open');
                titleBtn.setAttribute('aria-expanded', String(open));
            });

            checkbox.addEventListener('change', function () {
                onToggle(checkbox.checked);
            });

            slider.addEventListener('input', function () {
                const val = parseFloat(slider.value);
                value.textContent = formatPercent(val);
                onOpacityChange(val);
            });

            return {
                li,
                checkbox,
                slider
            };
        }

        function createSortable(listElement, onOrderChange) {
            let draggedItem = null;

            listElement.addEventListener('dragstart', function (event) {
                const handle = event.target.closest('.drag-handle');
                if (!handle) {
                    event.preventDefault();
                    return;
                }
                draggedItem = handle.closest('.item');
                if (!draggedItem) {
                    event.preventDefault();
                    return;
                }
                event.dataTransfer.effectAllowed = 'move';
                event.dataTransfer.setData('text/plain', draggedItem.dataset.id);
                requestAnimationFrame(function () {
                    draggedItem.classList.add('dragging');
                });
            });

            listElement.addEventListener('dragover', function (event) {
                if (!draggedItem) return;
                event.preventDefault();
                const after = getDragAfterElement(listElement, event.clientY);
                if (!after) {
                    listElement.appendChild(draggedItem);
                } else if (after !== draggedItem) {
                    listElement.insertBefore(draggedItem, after);
                }
            });

            function cleanup() {
                if (!draggedItem) return;
                draggedItem.classList.remove('dragging');
                draggedItem = null;
                const order = Array.from(listElement.children).map(function (item) {
                    return item.dataset.id;
                });
                onOrderChange(order);
            }

            listElement.addEventListener('drop', function (event) {
                event.preventDefault();
                cleanup();
            });

            listElement.addEventListener('dragend', function () {
                cleanup();
            });
        }

        function getDragAfterElement(container, y) {
            const items = Array.from(container.querySelectorAll('.item:not(.dragging)'));
            return items.reduce(function (closest, child) {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset, element: child };
                }
                return closest;
            }, { offset: Number.NEGATIVE_INFINITY, element: null }).element;
        }

        function showFeatureInfo(feature) {
            const props = feature?.properties || {};
            const title = props.title || 'Eintrag';
            const subtitle = props.subtitle || '';
            const description = props.description || '';
            const link = props.link || '';
            const image = props.image || '';
            const tags = Array.isArray(props.tags) ? props.tags : [];
            const era = props.era ? (Array.isArray(props.era) ? props.era : [props.era]) : [];

            elements.poiDetailTitle.textContent = title;

            let bodyHtml = '';
            if (subtitle) {
                bodyHtml += `<p class="muted">${escapeHTML(subtitle)}</p>`;
            }
            if (description) {
                bodyHtml += `<p>${escapeHTML(description)}</p>`;
            }
            if (image) {
                bodyHtml += `<img src="${escapeHTML(image)}" alt="${escapeHTML(title)}">`;
            }
            if (link) {
                bodyHtml += `<p><a href="${escapeHTML(link)}" target="_blank" rel="noopener">Mehr&nbsp;Infos</a></p>`;
            }

            elements.poiDetailBody.innerHTML = bodyHtml;

            elements.poiDetailTags.innerHTML = '';
            const mergedTags = tags.concat(era);
            if (mergedTags.length) {
                mergedTags.forEach(function (tag) {
                    const chip = document.createElement('span');
                    chip.className = 'chip';
                    chip.textContent = tag;
                    elements.poiDetailTags.appendChild(chip);
                });
            }

            elements.poiDetail.classList.remove('hidden');

            let matchedId = null;
            state.pois.forEach(function (record) {
                const isMatch = record.feature === feature;
                if (isMatch) {
                    matchedId = record.id;
                }
                record.element.classList.toggle('is-focused', isMatch);
            });
            state.activePoiId = matchedId;
        }

        function hidePoiDetail() {
            elements.poiDetail.classList.add('hidden');
            state.activePoiId = null;
            state.pois.forEach(function (record) {
                record.element.classList.remove('is-focused');
            });
        }

        function renderTutorial() {
            if (!state.tutorialVisible) {
                elements.tutorial.classList.add('hidden');
                elements.tutorialBadge.classList.add('is-visible');
                return;
            }

            if (!state.infoCards.length) {
                elements.tutorialTitle.textContent = 'Willkommen';
                elements.tutorialContent.innerHTML =
                    '<p>Ziehe historische Karten per Drag &amp; Drop in der linken Steuerung, um die Stapelreihenfolge anzupassen, und nutze die Zeitleiste unten rechts, um Inhalte nach Epochen einzublenden.</p>';
                elements.tutorialMeta.textContent = '';
                elements.tutorial.classList.remove('hidden');
                elements.tutorialBadge.classList.remove('is-visible');
                return;
            }

            if (state.tutorialIndex < 0 || state.tutorialIndex >= state.infoCards.length) {
                state.tutorialIndex = 0;
            }

            const card = state.infoCards[state.tutorialIndex];
            elements.tutorialTitle.textContent = card.title || 'Info';
            elements.tutorialContent.innerHTML = card.html;
            elements.tutorialMeta.textContent = `${state.tutorialIndex + 1} / ${state.infoCards.length}`;
            elements.tutorial.classList.remove('hidden');
            elements.tutorialBadge.classList.remove('is-visible');
        }

        function hideTutorial() {
            state.tutorialVisible = false;
            elements.tutorial.classList.add('hidden');
            elements.tutorialBadge.classList.add('is-visible');
        }

        function showTutorial() {
            state.tutorialVisible = true;
            renderTutorial();
        }

        async function loadInfoCards() {
            try {
                const indexList = await fetchJSON(DATA.cardsIdx, []);
                if (!Array.isArray(indexList)) return [];
                const cards = await Promise.all(indexList.map(function (entry) {
                    const file = entry?.file;
                    const title = entry?.title || '';
                    if (!file) return Promise.resolve(null);
                    return fetch(DATA.cardsDir + file, { cache: 'no-store' })
                        .then(function (res) {
                            if (!res.ok && res.status !== 0) throw new Error('fetch ' + file);
                            return res.text();
                        })
                        .then(function (markdown) {
                            return {
                                title,
                                html: mdToHtml(markdown)
                            };
                        })
                        .catch(function () {
                            return null;
                        });
                }));
                return cards.filter(Boolean);
            } catch (error) {
                console.warn('Infokarten konnten nicht geladen werden:', error);
                return [];
            }
        }

        function sanitizeEraList(list) {
            return list.map(function (name, index) {
                return sanitizeEraLabel(name, DEFAULT_ERAS[index] || `Epoche ${index + 1}`);
            });
        }

        function sanitizeEraLabel(name, fallback) {
            if (typeof name !== 'string') {
                return fallback;
            }
            let normalized = name;
            if (typeof normalized.normalize === 'function') {
                normalized = normalized.normalize('NFC');
            }
            const hasReplacement = normalized.indexOf('\uFFFD') !== -1;
            const hasLegacyMarker = /[\u01EC\u02DC\u02C6]/.test(normalized);
            if (!hasReplacement && !hasLegacyMarker) {
                return normalized;
            }
            try {
                const repaired = decodeURIComponent(escape(normalized));
                if (repaired && repaired.indexOf('\uFFFD') === -1 && !/[\u01EC\u02DC\u02C6]/.test(repaired)) {
                    return repaired;
                }
                return repaired || fallback;
            } catch (error) {
                console.warn('Konnte Era-Label nicht reparieren:', name, error);
                return fallback;
            }
        }

        function filterByEra(item) {
            let era = null;
            if (item && item.properties && item.properties.era !== undefined) {
                era = item.properties.era;
            } else if (item && item.era !== undefined) {
                era = item.era;
            }
            if (era === null || era === undefined) return true;
            const currentEra = ERAS[state.currentEraIndex];
            if (Array.isArray(era)) {
                return era.includes(currentEra);
            }
            return era === currentEra;
        }

        async function fetchJSON(url, fallback) {
            try {
                const res = await fetch(url, { cache: 'no-store' });
                if (!res.ok && res.status !== 0) throw new Error(res.status + ' ' + url);
                const raw = await res.text();
                if (!raw) return fallback;
                return JSON.parse(raw);
            } catch (error) {
                console.warn('Konnte JSON nicht laden, nutze Fallback:', url, error);
                return fallback;
            }
        }

        function mdToHtml(markdown) {
            if (!markdown) return '';
            let text = String(markdown).replace(/\r\n/g, '\n');

            text = text.replace(/[&<>]/g, function (char) {
                return { '&': '&amp;', '<': '&lt;', '>': '&gt;' }[char];
            });

            text = text.replace(/^### (.*)$/gm, '<h4>$1</h4>');
            text = text.replace(/^## (.*)$/gm, '<h3>$1</h3>');
            text = text.replace(/^# (.*)$/gm, '<h2>$1</h2>');

            text = text.replace(/(^|\n)- (.*)(?=(\n[^-]|$))/g, function (_, lead, items) {
                const listItems = items.split('\n- ').map(function (entry) {
                    return '<li>' + entry + '</li>';
                }).join('');
                return lead + '<ul>' + listItems + '</ul>';
            });

            text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');
            text = text.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
            text = text.replace(/\*([^*]+)\*/g, '<em>$1</em>');

            text = text.split(/\n{2,}/).map(function (block) {
                if (/^<h[2-4]>/.test(block) || /^<ul>/.test(block)) return block;
                return '<p>' + block.replace(/\n/g, '<br>') + '</p>';
            }).join('\n');

            return text;
        }

        function escapeHTML(str) {
            return String(str).replace(/[&<>"']/g, function (char) {
                return {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;'
                }[char];
            });
        }

        function createDefaultOverlayConfig() {
            const fallbackCenter = { lat: 51.1517, lng: 11.8096 };
            const center = map && typeof map.getCenter === 'function' ? map.getCenter() : fallbackCenter;
            const lat = typeof center.lat === 'number' ? center.lat : fallbackCenter.lat;
            const lng = typeof center.lng === 'number' ? center.lng : fallbackCenter.lng;
            const bounds = [
                [lat - DEFAULT_OVERLAY_DELTA.lat, lng - DEFAULT_OVERLAY_DELTA.lon],
                [lat + DEFAULT_OVERLAY_DELTA.lat, lng + DEFAULT_OVERLAY_DELTA.lon]
            ];
            return {
                id: 'historic-naumburg-base',
                title: 'Historische Karte Naumburg',
                url: DEFAULT_OVERLAY_IMAGE,
                bounds: bounds,
                rotation: 0,
                opacity: 0.65,
                defaultBase: true,
                fitOnActivate: true
            };
        }

        function toBounds(overlay) {
            if (overlay && Array.isArray(overlay.bounds) && overlay.bounds.length === 2) {
                return overlay.bounds;
            }
            if (overlay && overlay.corners) {
                const cornerValues = Object.values(overlay.corners);
                const lats = cornerValues.map(function (c) { return c[0]; });
                const lons = cornerValues.map(function (c) { return c[1]; });
                return [
                    [Math.min.apply(null, lats), Math.min.apply(null, lons)],
                    [Math.max.apply(null, lats), Math.max.apply(null, lons)]
                ];
            }
            throw new Error('Overlay ohne gültige bounds/corners');
        }

        function formatPercent(value) {
            return Math.round(value * 100) + '%';
        }

        function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }

        function fixLeafletIconPath() {
            const base = "https://unpkg.com/leaflet@1.9.4/dist/images/";
            L.Icon.Default.mergeOptions({
                iconRetinaUrl: base + 'marker-icon-2x.png',
                iconUrl: base + 'marker-icon.png',
                shadowUrl: base + 'marker-shadow.png'
            });
        }

        L.RotatedImageOverlay = L.ImageOverlay.extend({
            _initImage: function () {
                const img = L.DomUtil.create('img', 'leaflet-image-layer');
                img.style.position = 'absolute';
                img.style.willChange = 'transform';
                img.style.pointerEvents = this.options.interactive ? 'auto' : 'none';
                img.style.opacity = this.options.opacity;
                img.alt = this.options.alt || '';
                if (this.options.crossOrigin) img.crossOrigin = '';
                if (this.options.zIndex) img.style.zIndex = this.options.zIndex;
                img.src = this._url;

                const container = L.DomUtil.create('div', 'leaflet-rotated-container');
                container.style.position = 'absolute';
                container.style.top = '0';
                container.style.left = '0';
                container.style.width = '100%';
                container.style.height = '100%';
                container.style.overflow = 'visible';
                container.appendChild(img);

                this._image = img;
                this._container = container;
                this._imageContainer = container;
                this._image.onload = this._onImageLoad.bind(this);
            },
            _reset: function () {
                const map = this._map;
                const bounds = this._bounds;
                const nw = map.latLngToLayerPoint(bounds.getNorthWest());
                const ne = map.latLngToLayerPoint(bounds.getNorthEast());
                const sw = map.latLngToLayerPoint(bounds.getSouthWest());
                const width = Math.abs(ne.x - nw.x);
                const height = Math.abs(sw.y - nw.y);

                const centerLatLng = bounds.getCenter();
                const centerPoint = map.latLngToLayerPoint(centerLatLng);
                const topLeft = centerPoint.subtract(L.point(width / 2, height / 2));

                L.DomUtil.setPosition(this._container, topLeft);

                this._container.style.width = width + 'px';
                this._container.style.height = height + 'px';
                this._image.style.width = width + 'px';
                this._image.style.height = height + 'px';

                const angle = this.options.rotation || 0;

                let originX = width / 2;
                let originY = height / 2;

                if (this.options.pivot) {
                    const pivotPoint = map.latLngToLayerPoint(L.latLng(this.options.pivot));
                    const offset = pivotPoint.subtract(topLeft);
                    originX = offset.x;
                    originY = offset.y;
                }

                this._container.style.transformOrigin = originX + 'px ' + originY + 'px';
                this._container.style.transform = 'rotate(' + angle + 'deg)';
            },
            onAdd: function (map) {
                this._map = map;
                if (!this._container) this._initImage();
                map.getPanes().overlayPane.appendChild(this._container);
                map.on('zoomend viewreset resize move', this._reset, this);
                this._reset();
            },
            onRemove: function (map) {
                if (this._container && this._container.parentNode) {
                    this._container.parentNode.removeChild(this._container);
                }
                map.off('zoomend viewreset resize move', this._reset, this);
            },
            setRotation: function (angle) {
                this.options.rotation = angle;
                this._reset();
            }
        });

        function createRotatedImageOverlay(url, bounds, options, rotation) {
            options = options || {};
            options.rotation = rotation || 0;
            return new L.RotatedImageOverlay(url, bounds, options);
        }
    </script>
</body>

</html>

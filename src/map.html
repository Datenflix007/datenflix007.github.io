<!doctype html>
<html lang="de">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1, width=device-width" />
    <title>Naumburg Interaktiv</title>

    <!-- Leaflet (CDN) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="">
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <style>
        html,
        body,
        #map {
            height: 100%;
            margin: 0;
        }
        
         :root {
            --panel-bg: rgba(255, 255, 255, 0.92);
            --panel-border: rgba(0, 0, 0, 0.15);
            --panel-radius: 12px;
            --accent: #0a7cff;
            --muted: #666;
            --chip-bg: #f1f5f9;
        }
        
        #ui {
            position: absolute;
            top: 12px;
            left: 12px;
            z-index: 1000;
            background: var(--panel-bg);
            backdrop-filter: saturate(1.2) blur(4px);
            border: 1px solid var(--panel-border);
            border-radius: var(--panel-radius);
            padding: 12px;
            font-family: system-ui, sans-serif;
            max-width: 360px;
            box-shadow: 0 10px 24px rgba(0, 0, 0, .12);
        }
        
        #ui h2 {
            font-size: 14px;
            margin: 0 0 8px;
        }
        
        #ui .row {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 8px;
            align-items: center;
            margin: 6px 0;
        }
        
        #ui label {
            font-size: 13px;
            color: #111;
        }
        
        #ui small {
            color: var(--muted);
        }
        
        #eraLabels {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: var(--muted);
            margin-top: 4px;
            gap: 4px;
        }
        
        .sep {
            height: 1px;
            background: #e5e7eb;
            margin: 8px 0;
        }
        
        input[type="range"] {
            width: 100%;
        }
        
        .leaflet-control-attribution {
            font-size: 11px;
        }
        /* Info-Panel */
        
        #info {
            position: absolute;
            right: 12px;
            bottom: 12px;
            z-index: 1000;
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: var(--panel-radius);
            padding: 12px;
            width: min(420px, 92vw);
            font-family: system-ui, sans-serif;
            max-height: 50%;
            overflow: auto;
            box-shadow: 0 10px 24px rgba(0, 0, 0, .12);
        }
        
        #info h3 {
            margin: 0 0 6px;
            font-size: 16px;
        }
        
        #info p {
            margin: 0 0 10px;
            font-size: 13px;
            line-height: 1.4;
        }
        
        .muted {
            color: var(--muted);
            font-size: 12px;
        }
        
        .chip {
            background: var(--chip-bg);
            border-radius: 999px;
            padding: 2px 8px;
            font-size: 11px;
        }
        
        #chips {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-top: 6px;
        }
        /* Infokarten Controls */
        
        .info-controls {
            position: sticky;
            top: 0;
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 6px;
            margin: -6px -6px 8px 0;
        }
        
        .btn-icon {
            appearance: none;
            border: 1px solid var(--panel-border);
            background: #fff;
            border-radius: 10px;
            width: 28px;
            height: 28px;
            display: inline-grid;
            place-items: center;
            cursor: pointer;
            font-weight: 700;
            line-height: 1;
            padding: 0;
        }
        
        .btn-icon:hover {
            filter: brightness(0.98);
        }
        
        .nav-wrap {
            display: flex;
            gap: 6px;
            margin-left: auto;
        }
        
        .info-meta {
            font-size: 12px;
            color: #333;
            margin-left: auto;
        }
        /* Hilfe-Button rechts unten */
        
        #helpBtn {
            position: absolute;
            right: 16px;
            bottom: 16px;
            z-index: 900;
            width: 42px;
            height: 42px;
            border-radius: 50%;
            background: #fff;
            border: 1px solid var(--panel-border);
            box-shadow: 0 8px 18px rgba(0, 0, 0, .15);
            display: grid;
            place-items: center;
            cursor: pointer;
            font-weight: 800;
        }
    </style>
</head>

<body>
    <div id="map"></div>

    <!-- UI Panel -->
    <section id="ui" role="region" aria-label="Kartensteuerung">
        <h2>Steuerung</h2>
        <div class="row">
            <label for="era">Epoche <small id="eraName"></small></label>
            <output id="eraIndex" aria-live="polite"></output>
        </div>
        <input id="era" type="range" min="0" max="5" step="1" value="0" aria-label="Zeitleiste">
        <div id="eraLabels">
            <span>Fr√ºh-</span><span>Hoch-</span><span>Sp√§t-</span><span>Fr√ºhe Neuzeit</span><span>Moderne</span><span>Postmod.</span>
        </div>
        <div class="sep"></div>
        <div class="row">
            <label class="switch"><input id="toggleOverlays" type="checkbox" checked> Karten einblenden</label>
            <small id="overlayCount" class="muted"></small>
        </div>
        <div class="row">
            <label for="overlayOpacity">Karten-Transparenz</label>
            <output id="opacityVal">0.6</output>
        </div>
        <input id="overlayOpacity" type="range" min="0" max="1" step="0.05" value="0.6" aria-label="Overlay-Transparenz">
    </section>

    <!-- Info Panel (POI/Polygon-Infos & Infokarten) -->
    <aside id="info" aria-live="polite"></aside>

    <!-- Hilfe-Button -->
    <button id="helpBtn" title="Hilfe (Infokarten anzeigen)">?</button>

    <script>
        // --------- Konfiguration & Epochen ----------
        var DEFAULT_ERAS = ["Fr√ºhmittelalter", "Hochmittelalter", "Sp√§tmittelalter", "Fr√ºhe Neuzeit", "Moderne", "Postmoderne"];

        // Datenquellen
        var DATA = {
            config: 'assets/data/config.json',
            pois: 'assets/data/pois.json',
            polygons: 'assets/data/polygons.geojson',
            overlays: 'assets/data/overlays.json',
            cardsIdx: 'assets/infocards/index.json', // <- Liste der Markdown-Dateien
            cardsDir: 'assets/infocards/'
        };

        // Globale Variablen/Layers
        var map, poiLayer, polygonLayer;
        var overlayLayers = [];
        var ERAS = DEFAULT_ERAS;
        var currentEraIndex = 0;

        // Infokarten
        var infoCards = []; // [{title, file, html}]
        var infoCardIndex = 0; // aktueller Slide
        var infoPanelOpen = true; // Status

        // Leaflet-Icons fixen (CDN)
        (function fixLeafletIconPath() {
            var base = "https://unpkg.com/leaflet@1.9.4/dist/images/";
            var LIcon = L.Icon.Default;
            LIcon.mergeOptions({
                iconRetinaUrl: base + 'marker-icon-2x.png',
                iconUrl: base + 'marker-icon.png',
                shadowUrl: base + 'marker-shadow.png'
            });
        })();

        // --------- Init ----------
        (async function init() {
            // 1) Config
            var cfg = await fetchJSON(DATA.config, {
                start: {
                    lat: 52.52,
                    lon: 13.405,
                    zoom: 12
                },
                eras: DEFAULT_ERAS
            });
            ERAS = (cfg && Array.isArray(cfg.eras) && cfg.eras.length) ? cfg.eras : DEFAULT_ERAS;

            // 2) Map
            map = L.map('map', {
                center: [cfg.start.lat, cfg.start.lon],
                zoom: cfg.start.zoom,
                preferCanvas: true
            });

            // 3) OSM
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 20,
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> Mitwirkende'
            }).addTo(map);

            // 4) Daten
            var all = await Promise.all([
                fetchJSON(DATA.pois, {
                    features: []
                }),
                fetchJSON(DATA.polygons, {
                    type: "FeatureCollection",
                    features: []
                }),
                fetchJSON(DATA.overlays, []),
                loadInfoCards() // Infokarten laden
            ]);
            var pois = all[0];
            var polygons = all[1];
            var overlays = all[2];

            // 5) POIs
            poiLayer = L.geoJSON(pois, {
                pointToLayer: function(feature, latlng) {
                    var title = "POI";
                    if (feature && feature.properties && feature.properties.title !== undefined && feature.properties.title !== null && feature.properties.title !== "") {
                        title = feature.properties.title;
                    }
                    var m = L.marker(latlng, {
                        title: title
                    });
                    m.on('click', function() {
                        showFeatureInfo(feature);
                    });
                    return m;
                },
                filter: function(f) {
                    return filterByEra(f);
                }
            }).addTo(map);

            // 6) Polygone
            polygonLayer = L.geoJSON(polygons, {
                style: function(f) {
                    var p = (f && f.properties) ? f.properties : {};
                    var color = (p.stroke !== undefined && p.stroke !== null && p.stroke !== '') ? p.stroke : '#0a7cff';
                    var weight = (p['stroke-width'] !== undefined && p['stroke-width'] !== null && p['stroke-width'] !== '') ? Number(p['stroke-width']) : 2;
                    var opacity = (p['stroke-opacity'] !== undefined && p['stroke-opacity'] !== null && p['stroke-opacity'] !== '') ? Number(p['stroke-opacity']) : 0.9;
                    var fillColor = (p.fill !== undefined && p.fill !== null && p.fill !== '') ? p.fill : '#0a7cff';
                    var fillOpacity = (p['fill-opacity'] !== undefined && p['fill-opacity'] !== null && p['fill-opacity'] !== '') ? Number(p['fill-opacity']) : 0.15;
                    return {
                        color: color,
                        weight: weight,
                        opacity: opacity,
                        fillColor: fillColor,
                        fillOpacity: fillOpacity
                    };
                },
                onEachFeature: function(feature, layer) {
                    layer.on('click', function() {
                        showFeatureInfo(feature);
                    });
                },
                filter: function(f) {
                    return filterByEra(f);
                }
            }).addTo(map);

            // 7) Overlays
            overlayLayers = overlays.map(function(ov) {
                var bounds = toBounds(ov);
                var rotation = ov.rotation || 0;
                var layer = createRotatedImageOverlay(ov.url, bounds, {
                    opacity: 0.6,
                    interactive: false,
                    crossOrigin: 'anonymous'
                }, rotation);
                if (filterByEra({
                        properties: ov
                    })) {
                    layer.addTo(map);
                }
                return layer;
            });
            updateOverlayMeta();

            // 8) UI
            setupUI(cfg);

            // 9) Start-Bounds optional
            if (cfg && Array.isArray(cfg.fitBounds) && cfg.fitBounds.length === 2) {
                map.fitBounds(cfg.fitBounds);
            }

            // 10) Zu Beginn: Infokarten anzeigen
            renderInfoCards();
        })();

        // --------- Helpers ----------
        async function fetchJSON(url, fallback) {
            try {
                var res = await fetch(url, {
                    cache: 'no-store'
                });
                if (!res.ok) throw new Error(res.status + ' ' + url);
                return await res.json();
            } catch (e) {
                console.warn('Konnte JSON nicht laden, nutze Fallback:', url, e);
                return fallback;
            }
        }

        function filterByEra(feature) {
            var propEra = null;
            if (feature && feature.properties && feature.properties.era !== undefined && feature.properties.era !== null) {
                propEra = feature.properties.era;
            }
            if (propEra === null) return true;
            var eraName = ERAS[currentEraIndex];
            if (Array.isArray(propEra)) return propEra.indexOf(eraName) !== -1;
            return propEra === eraName;
        }

        function refreshFilters() {
            // POIs
            poiLayer.clearLayers();
            fetchJSON(DATA.pois, {
                features: []
            }).then(function(pois) {
                if (pois && pois.features) {
                    poiLayer.addData(pois.features);
                } else {
                    poiLayer.addData(pois);
                }
            });
            // Polygone
            polygonLayer.clearLayers();
            fetchJSON(DATA.polygons, {
                type: "FeatureCollection",
                features: []
            }).then(function(polygons) {
                polygonLayer.addData(polygons);
            });
            // Overlays
            fetchJSON(DATA.overlays, []).then(function(overlays) {
                overlayLayers.forEach(function(l) {
                    map.removeLayer(l);
                });
                overlayLayers = overlays.map(function(ov) {
                    var bounds = toBounds(ov);
                    var layer = L.imageOverlay(ov.url, bounds, {
                        opacity: parseFloat(document.getElementById('overlayOpacity').value),
                        interactive: false,
                        crossOrigin: 'anonymous'
                    });
                    var toggleEl = document.getElementById('toggleOverlays');
                    var visible = false;
                    if (toggleEl && toggleEl.checked && filterByEra({
                            properties: ov
                        })) {
                        visible = true;
                    }
                    if (visible) {
                        layer.addTo(map);
                    }
                    return layer;
                });
                updateOverlayMeta();
            });
        }

        function toBounds(ov) {
            if (ov && Array.isArray(ov.bounds) && ov.bounds.length === 2) return ov.bounds;
            if (ov && ov.corners) {
                var lats = Object.values(ov.corners).map(function(c) {
                    return c[0];
                });
                var lons = Object.values(ov.corners).map(function(c) {
                    return c[1];
                });
                return [
                    [Math.min.apply(null, lats), Math.min.apply(null, lons)],
                    [Math.max.apply(null, lats), Math.max.apply(null, lons)]
                ];
            }
            throw new Error('Overlay ohne g√ºltige bounds/corners');
        }

        function setupUI(cfg) {
            var eraInput = document.getElementById('era');
            var eraName = document.getElementById('eraName');
            var eraIndexOut = document.getElementById('eraIndex');
            var toggleOverlays = document.getElementById('toggleOverlays');
            var overlayOpacity = document.getElementById('overlayOpacity');
            var opacityVal = document.getElementById('opacityVal');

            eraInput.max = ERAS.length - 1;

            function updateEraUI(idx) {
                eraName.textContent = '¬∑ ' + ERAS[idx];
                eraIndexOut.textContent = (parseInt(idx, 10) + 1) + '/' + ERAS.length;
            }

            var url = new URL(location.href);
            var pEra = url.searchParams.get('era');
            var startIdx;
            if (pEra && ERAS.indexOf(pEra) >= 0) {
                startIdx = Math.max(0, ERAS.indexOf(pEra));
            } else if (cfg && cfg.startEraIndex !== undefined && cfg.startEraIndex !== null) {
                startIdx = cfg.startEraIndex;
            } else {
                startIdx = 0;
            }
            currentEraIndex = isFinite(startIdx) ? startIdx : 0;

            eraInput.value = currentEraIndex;
            updateEraUI(currentEraIndex);

            eraInput.addEventListener('input', function(e) {
                currentEraIndex = parseInt(e.target.value, 10);
                updateEraUI(currentEraIndex);
                refreshFilters();
            });
            toggleOverlays.addEventListener('change', function() {
                overlayLayers.forEach(function(l) {
                    if (toggleOverlays.checked) l.addTo(map);
                    else map.removeLayer(l);
                });
                updateOverlayMeta();
            });
            overlayOpacity.addEventListener('input', function(e) {
                var v = parseFloat(e.target.value);
                opacityVal.textContent = v.toFixed(2);
                overlayLayers.forEach(function(l) {
                    l.setOpacity(v);
                });
            });

            var pLat = parseFloat(url.searchParams.get('lat'));
            var pLon = parseFloat(url.searchParams.get('lon'));
            var pZ = parseInt(url.searchParams.get('z'), 10);
            if (isFinite(pLat) && isFinite(pLon)) map.setView([pLat, pLon], isFinite(pZ) ? pZ : map.getZoom());

            // Hilfe-Button
            var hb = document.getElementById('helpBtn');
            hb.addEventListener('click', function() {
                infoPanelOpen = true;
                infoCardIndex = 0;
                renderInfoCards();
            });
        }

        function updateOverlayMeta() {
            var m = document.getElementById('overlayCount');
            var count = overlayLayers.filter(function(l) {
                return map.hasLayer(l);
            }).length;
            m.textContent = count + ' sichtbar';
        }

        // ---------- POI/Polygon-Info ----------
        function showFeatureInfo(feature) {
            infoPanelOpen = true; // Panel sichtbar halten
            var info = document.getElementById('info');
            var p = (feature && feature.properties) ? feature.properties : {};
            var title = (p.title !== undefined && p.title !== null && p.title !== "") ? p.title : "Objekt";

            var html = '';
            html += '<div class="info-controls">';
            html += '  <button class="btn-icon" id="closeInfo" title="Schlie√üen">√ó</button>';
            html += '</div>';
            html += '<h3>' + escapeHTML(title) + '</h3>';
            if (p.subtitle) html += '<p class="muted">' + escapeHTML(p.subtitle) + '</p>';
            if (p.description) html += '<p>' + escapeHTML(p.description) + '</p>';
            if (p.link) html += '<p><a href="' + p.link + '" target="_blank" rel="noopener">Mehr&nbsp;Infos</a></p>';

            // Chips
            var tags = Array.isArray(p.tags) ? p.tags : [];
            var era = p.era ? (Array.isArray(p.era) ? p.era : [p.era]) : [];
            if (tags.length || era.length) {
                html += '<div id="chips">';
                tags.concat(era).forEach(function(t) {
                    html += '<span class="chip">' + escapeHTML(t) + '</span>';
                });
                html += '</div>';
            }

            var infoEl = document.getElementById('info');
            infoEl.innerHTML = html;

            document.getElementById('closeInfo').addEventListener('click', function() {
                hideInfoPanel();
            });
        }

        function hideInfoPanel() {
            var info = document.getElementById('info');
            info.innerHTML = '';
            infoPanelOpen = false;
        }

        // ---------- Infokarten (Markdown) ----------
        async function loadInfoCards() {
            try {
                var idx = await fetchJSON(DATA.cardsIdx, []);
                if (!Array.isArray(idx)) idx = [];
                // Lade alle Markdown-Dateien und render sie zu HTML
                var promises = idx.map(function(entry) {
                    var file = entry && entry.file ? entry.file : null;
                    var title = entry && entry.title ? entry.title : '';
                    if (!file) return Promise.resolve(null);
                    return fetch(DATA.cardsDir + file, {
                            cache: 'no-store'
                        })
                        .then(function(res) {
                            if (!res.ok) throw new Error('fetch ' + file);
                            return res.text();
                        })
                        .then(function(md) {
                            return {
                                title: title,
                                file: file,
                                html: mdToHtml(md)
                            };
                        })
                        .catch(function() {
                            return null;
                        });
                });
                var results = await Promise.all(promises);
                infoCards = results.filter(function(x) {
                    return x !== null;
                });
            } catch (e) {
                console.warn('Infokarten konnten nicht geladen werden:', e);
                infoCards = [];
            }
        }

        function renderInfoCards() {
            var info = document.getElementById('info');
            if (!infoCards.length) {
                // Fallback-Card
                info.innerHTML =
                    '<div class="info-controls"><button class="btn-icon" id="closeInfo" title="Schlie√üen">√ó</button></div>' +
                    '<h3>Willkommen üëã</h3>' +
                    '<p class="muted">Klicke auf einen POI oder eine Fl√§che, um Details zu sehen. √úber den ?-Button unten rechts √∂ffnest du diese Hilfe erneut.</p>';
                document.getElementById('closeInfo').addEventListener('click', function() {
                    hideInfoPanel();
                });
                return;
            }

            // Clamp Index
            if (infoCardIndex < 0) infoCardIndex = infoCards.length - 1;
            if (infoCardIndex >= infoCards.length) infoCardIndex = 0;

            var card = infoCards[infoCardIndex];
            var html = '';
            html += '<div class="info-controls">';
            html += '  <div class="nav-wrap">';
            html += '    <button class="btn-icon" id="prevCard" title="Zur√ºck">‚Äπ</button>';
            html += '    <button class="btn-icon" id="nextCard" title="Weiter">‚Ä∫</button>';
            html += '  </div>';
            html += '  <button class="btn-icon" id="closeInfo" title="Schlie√üen">√ó</button>';
            html += '</div>';
            html += '<h3>' + escapeHTML(card.title || 'Info') + '</h3>';
            html += '<div>' + card.html + '</div>';
            html += '<div class="info-meta">' + (infoCardIndex + 1) + ' / ' + infoCards.length + '</div>';

            info.innerHTML = html;

            // Events
            document.getElementById('prevCard').addEventListener('click', function() {
                infoCardIndex--;
                renderInfoCards();
            });
            document.getElementById('nextCard').addEventListener('click', function() {
                infoCardIndex++;
                renderInfoCards();
            });
            document.getElementById('closeInfo').addEventListener('click', function() {
                hideInfoPanel();
            });

            // Tastatur-Navigation
            document.onkeydown = function(ev) {
                var e = ev || window.event;
                if (!infoPanelOpen) return;
                if (e.key === 'ArrowLeft') {
                    infoCardIndex--;
                    renderInfoCards();
                }
                if (e.key === 'ArrowRight') {
                    infoCardIndex++;
                    renderInfoCards();
                }
                if (e.key === 'Escape') {
                    hideInfoPanel();
                }
            };
        }

        // Sehr einfacher Markdown ‚Üí HTML Konverter (√úberschriften, Listen, Links, **fett**, *kursiv*)
        function mdToHtml(md) {
            if (md === undefined || md === null) return '';
            var text = String(md).replace(/\r\n/g, '\n');

            // Escape HTML vor der Umwandlung
            text = text.replace(/[&<>]/g, function(s) {
                return {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;'
                }[s];
            });

            // √úberschriften
            text = text.replace(/^### (.*)$/gm, '<h4>$1</h4>');
            text = text.replace(/^## (.*)$/gm, '<h3>$1</h3>');
            text = text.replace(/^# (.*)$/gm, '<h2>$1</h2>');

            // Listen
            text = text.replace(/(^|\n)- (.*)(?=(\n[^-]|$))/g, function(match, p1, p2) {
                var items = p2.split('\n- ').map(function(li) {
                    return '<li>' + li + '</li>';
                }).join('');
                return p1 + '<ul>' + items + '</ul>';
            });

            // Links [text](url)
            text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');

            // Fett/Kursiv
            text = text.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
            text = text.replace(/\*([^*]+)\*/g, '<em>$1</em>');

            // Abs√§tze (Doppel-Zeilenumbruch ‚Üí <p>)
            text = text.split(/\n{2,}/).map(function(block) {
                if (/^<h[2-4]>/.test(block) || /^<ul>/.test(block)) return block;
                return '<p>' + block.replace(/\n/g, '<br>') + '</p>';
            }).join('\n');

            return text;
        }

        function escapeHTML(str) {
            return String(str).replace(/[&<>"']/g, function(s) {
                return ({
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;'
                })[s];
            });
        }

        // --- RotatedImageOverlay-Klasse ---
        L.RotatedImageOverlay = L.ImageOverlay.extend({
            _initImage: function() {
                var img = L.DomUtil.create('img', 'leaflet-image-layer');
                img.style.position = 'absolute';
                img.style.willChange = 'transform';
                img.style.pointerEvents = this.options.interactive ? 'auto' : 'none';
                img.style.opacity = this.options.opacity;
                img.alt = this.options.alt || '';
                if (this.options.crossOrigin) img.crossOrigin = '';
                if (this.options.zIndex) img.style.zIndex = this.options.zIndex;
                img.src = this._url;

                // Container f√ºr Rotation
                var container = L.DomUtil.create('div', 'leaflet-rotated-container');
                container.style.position = 'absolute';
                container.style.top = '0';
                container.style.left = '0';
                container.style.width = '100%';
                container.style.height = '100%';
                container.style.overflow = 'visible';
                container.appendChild(img);

                this._image = img;
                this._container = container;
                this._imageContainer = container;
                this._image.onload = this._onImageLoad.bind(this);
            },
            _reset: function() {
                var nw = this._map.latLngToLayerPoint(this._bounds.getNorthWest());
                var se = this._map.latLngToLayerPoint(this._bounds.getSouthEast());
                var size = se.subtract(nw);

                L.DomUtil.setPosition(this._container, nw);

                this._container.style.width = Math.abs(size.x) + 'px';
                this._container.style.height = Math.abs(size.y) + 'px';
                this._image.style.width = Math.abs(size.x) + 'px';
                this._image.style.height = Math.abs(size.y) + 'px';

                // Rotation um Mittelpunkt
                var angle = this.options.rotation || 0;
                var cx = Math.abs(size.x) / 2;
                var cy = Math.abs(size.y) / 2;
                this._container.style.transformOrigin = cx + 'px ' + cy + 'px';
                this._container.style.transform = 'rotate(' + angle + 'deg)';
            },
            onAdd: function(map) {
                this._map = map;
                if (!this._container) this._initImage();
                map.getPanes().overlayPane.appendChild(this._container);
                map.on('zoomend viewreset resize move', this._reset, this);
                this._reset();
            },
            onRemove: function(map) {
                if (this._container && this._container.parentNode) {
                    this._container.parentNode.removeChild(this._container);
                }
                map.off('zoomend viewreset resize move', this._reset, this);
            },
            setRotation: function(angle) {
                this.options.rotation = angle;
                this._reset();
            }
        });

        function createRotatedImageOverlay(url, bounds, options, rotation) {
            options = options || {};
            options.rotation = rotation || 0;
            return new L.RotatedImageOverlay(url, bounds, options);
        }

        // --- Overlays laden und einf√ºgen ---
        fetch('assets/data/overlays.json')
            .then(res => res.json())
            .then(overlays => {
                overlays.forEach(function(ov) {
                    var bounds = ov.bounds;
                    var rotation = ov.rotation || 0;
                    var layer = createRotatedImageOverlay(ov.url, bounds, {
                        opacity: 0.6,
                        interactive: false,
                        crossOrigin: 'anonymous'
                    }, rotation);
                    layer.addTo(map);
                });
            });
    </script>
</body>

</html>
<!doctype html>
<html lang="de">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1, width=device-width" />
    <title>Naumburg Interaktiv</title>

    <!-- Lokale Styles (fallen ggf. automatisch auf CDN zurück) -->
    <link id="leaflet-css" rel="stylesheet" href="../lib/leaflet/leaflet.css">
    <link id="ldi-css" rel="stylesheet" href="../lib/leaflet-distortableimage/leaflet.distortableimage.min.css">

    <style>
        html,
        body,
        #map {
            height: 100%;
            margin: 0;
        }
        
         :root {
            --panel-bg: rgba(255, 255, 255, .92);
            --panel-border: rgba(0, 0, 0, .15);
            --panel-radius: 12px;
            --muted: #666;
        }
        
        #ui {
            position: absolute;
            top: 12px;
            left: 12px;
            z-index: 1000;
            background: var(--panel-bg);
            backdrop-filter: saturate(1.2) blur(4px);
            border: 1px solid var(--panel-border);
            border-radius: var(--panel-radius);
            padding: 12px;
            font-family: system-ui, sans-serif;
            max-width: 360px;
            box-shadow: 0 10px 24px rgba(0, 0, 0, .12);
        }
        
        #ui h2 {
            font-size: 14px;
            margin: 0 0 8px
        }
        
        #ui .row {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 8px;
            align-items: center;
            margin: 6px 0
        }
        
        #eraLabels {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: var(--muted);
            margin-top: 4px;
            gap: 4px
        }
        
        .sep {
            height: 1px;
            background: #e5e7eb;
            margin: 8px 0
        }
        
        input[type="range"] {
            width: 100%
        }
        
        .leaflet-control-attribution {
            font-size: 11px
        }
        
        #info {
            position: absolute;
            right: 12px;
            bottom: 12px;
            z-index: 1000;
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: var(--panel-radius);
            padding: 12px;
            width: min(420px, 92vw);
            font-family: system-ui, sans-serif;
            max-height: 50%;
            overflow: auto;
            box-shadow: 0 10px 24px rgba(0, 0, 0, .12);
        }
        
        .btn-icon {
            appearance: none;
            border: 1px solid var(--panel-border);
            background: #fff;
            border-radius: 10px;
            width: 28px;
            height: 28px;
            display: inline-grid;
            place-items: center;
            cursor: pointer;
            font-weight: 700;
            line-height: 1;
            padding: 0
        }
        
        .nav-wrap {
            display: flex;
            gap: 6px
        }
        
        #helpBtn {
            position: absolute;
            right: 16px;
            bottom: 16px;
            z-index: 900;
            width: 42px;
            height: 42px;
            border-radius: 50%;
            background: #fff;
            border: 1px solid var(--panel-border);
            box-shadow: 0 8px 18px rgba(0, 0, 0, .15);
            display: grid;
            place-items: center;
            cursor: pointer;
            font-weight: 800
        }
    </style>
</head>

<body>
    <div id="map"></div>

    <section id="ui" role="region" aria-label="Kartensteuerung">
        <h2>Steuerung</h2>

        <div class="row">
            <label for="era">Epoche <small id="eraName"></small></label>
            <output id="eraIndex"></output>
        </div>
        <input id="era" type="range" min="0" max="5" step="1" value="0" aria-label="Zeitleiste">
        <div id="eraLabels">
            <span>Früh-</span><span>Hoch-</span><span>Spät-</span><span>Frühe Neuzeit</span><span>Moderne</span><span>Postmod.</span>
        </div>

        <div class="sep"></div>

        <div class="row">
            <label><input id="toggleOverlays" type="checkbox" checked> Karten einblenden</label>
            <small id="overlayCount" class="muted"></small>
        </div>

        <div class="row">
            <label for="overlayOpacity">Karten-Transparenz</label>
            <output id="opacityVal">0.60</output>
        </div>
        <input id="overlayOpacity" type="range" min="0" max="1" step="0.05" value="0.6" aria-label="Overlay-Transparenz">

        <div class="row">
            <label>Rotation</label>
            <div class="nav-wrap">
                <button class="btn-icon" id="rotLeft" title="Links drehen">↶</button>
                <button class="btn-icon" id="rotRight" title="Rechts drehen">↷</button>
            </div>
        </div>
    </section>

    <aside id="info" aria-live="polite"></aside>
    <button id="helpBtn" title="Hilfe">?</button>

    <!-- Lokale Skripte mit CDN-Fallback -->
    <script src="../lib/leaflet/leaflet.js" onerror="this.onerror=null; this.src='https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';"></script>
    <script src="../lib/leaflet-distortableimage/leaflet.distortableimage.min.js" onerror="this.onerror=null; this.src='https://cdn.jsdelivr.net/npm/leaflet-distortableimage@0.21.9/dist/leaflet.distortableimage.js';"></script>

    <script>
        // Fallback für CSS (wenn lokale Pfade nicht existieren)
        (function ensureCss() {
            function add(url) {
                var l = document.createElement('link');
                l.rel = 'stylesheet';
                l.href = url;
                document.head.appendChild(l);
            }
            // Prüfen nach dem Laden des ersten Scripts, ob Leaflet existiert. Wenn nicht, CSS-Fallback anhängen.
            window.addEventListener('load', function() {
                if (typeof L === 'undefined') {
                    add('https://unpkg.com/leaflet@1.9.4/dist/leaflet.css');
                }
                // DistortableImage CSS sicherheitshalber immer ergänzen, falls lokal fehlt:
                if (!document.querySelector('link[href*="leaflet.distortableimage"]')) {
                    add('https://cdn.jsdelivr.net/npm/leaflet-distortableimage@0.21.9/dist/leaflet.distortableimage.css');
                }
            });
        })();

        // ---------- Grundkonfiguration ----------
        const DEFAULT_ERAS = ["Frühmittelalter", "Hochmittelalter", "Spätmittelalter", "Frühe Neuzeit", "Moderne", "Postmoderne"];
        const DATA = {
            config: 'assets/data/config.json',
            overlays: 'assets/data/overlays.json'
        };

        let map, overlayLayers = [];
        let ERAS = DEFAULT_ERAS;
        let currentEraIndex = 0;

        // Leaflet-Icons fix – sicher gegen fehlendes Leaflet
        (function fixLeafletIcons() {
            if (!(window.L && L.Icon && L.Icon.Default)) return;
            const base = (location.pathname.indexOf('/src/') > -1 ? '../lib/leaflet/images/' : './lib/leaflet/images/');
            L.Icon.Default.mergeOptions({
                iconRetinaUrl: base + 'marker-icon-2x.png',
                iconUrl: base + 'marker-icon.png',
                shadowUrl: base + 'marker-shadow.png'
            });
        })();

        // ---------- Init ----------
        (async function init() {
            // Warten bis Leaflet lädt; wenn nicht vorhanden, erneut in 100ms prüfen (max 20x)
            for (let i = 0; i < 20 && typeof L === 'undefined'; i++) {
                await new Promise(r => setTimeout(r, 100));
            }
            if (typeof L === 'undefined') {
                console.error('Leaflet konnte nicht geladen werden.');
                return;
            }

            const cfg = await fetchJSON(DATA.config, {
                start: {
                    lat: 51.15,
                    lon: 11.81,
                    zoom: 14
                },
                eras: DEFAULT_ERAS
            });
            ERAS = Array.isArray(cfg.eras) && cfg.eras.length ? cfg.eras : DEFAULT_ERAS;

            map = L.map('map', {
                center: [cfg.start.lat, cfg.start.lon],
                zoom: cfg.start.zoom,
                preferCanvas: true
            });

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 20,
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> Mitwirkende'
            }).addTo(map);

            const overlays = await fetchJSON(DATA.overlays, []);
            addOverlaysForCurrentEra(overlays);

            if (!cfg.fitBounds && overlays.length) {
                const allCorners = overlays.flatMap(o => (o.corners || [])).map(c => L.latLng(c[0], c[1]));
                if (allCorners.length) map.fitBounds(L.latLngBounds(allCorners));
            }

            setupUI(cfg, overlays);
        })();

        // ---------- Helpers ----------
        async function fetchJSON(url, fallback) {
            try {
                const res = await fetch(url, {
                    cache: 'no-store'
                });
                if (!res.ok) throw new Error(res.status + ' ' + url);
                return await res.json();
            } catch (e) {
                return fallback;
            }
        }

        function filterByEraName(eraProp) {
            if (eraProp == null) return true;
            const active = ERAS[currentEraIndex];
            if (Array.isArray(eraProp)) return eraProp.includes(active);
            return eraProp === active;
        }

        function addOverlaysForCurrentEra(overlays) {
            overlayLayers.forEach(l => map.removeLayer(l));
            overlayLayers = [];

            const toggle = document.getElementById('toggleOverlays');
            const opacity = parseFloat(document.getElementById('overlayOpacity').value);

            overlays.forEach(ov => {
                if (!ov || !Array.isArray(ov.corners) || ov.corners.length < 4) return;
                if (!filterByEraName(ov.era)) return;

                const bounds = [ov.corners[0], ov.corners[3]];
                const rotation = ov.rotate || 0;

                const layer = L.imageOverlay(ov.url, bounds, {
                    opacity: opacity
                });

                function applyRotation() {
                    const img = layer.getElement();
                    if (img) {
                        img.style.transformOrigin = "center center";
                        img.style.transform = `rotate(${rotation}deg)`;
                    }
                }

                layer.on('add', applyRotation);
                layer.on('load', applyRotation);

                map.on('zoomend moveend viewreset', applyRotation);

                overlayLayers.push(layer);
                if (toggle.checked) layer.addTo(map);
            });

            updateOverlayMeta();
        }

        function updateOverlayMeta() {
            const m = document.getElementById('overlayCount');
            const count = overlayLayers.filter(l => map.hasLayer(l)).length;
            m.textContent = count + ' sichtbar';
        }

        function setupUI(cfg, overlays) {
            const eraInput = document.getElementById('era');
            const eraNameOut = document.getElementById('eraName');
            const eraIndexOut = document.getElementById('eraIndex');
            const toggleOverlays = document.getElementById('toggleOverlays');
            const overlayOpacity = document.getElementById('overlayOpacity');
            const opacityVal = document.getElementById('opacityVal');

            // --- Epoche initialisieren ---
            eraInput.max = Math.max(0, ERAS.length - 1);
            let startEra = Number.isInteger(cfg && cfg.startEraIndex) ? cfg.startEraIndex : 0;
            startEra = Math.min(Math.max(startEra, 0), ERAS.length - 1);
            currentEraIndex = startEra;
            eraInput.value = String(currentEraIndex);
            updateEraUI(currentEraIndex);
            addOverlaysForCurrentEra(overlays);

            eraInput.addEventListener('input', (e) => {
                const idx = parseInt(e.target.value, 10);
                if (!Number.isNaN(idx)) {
                    currentEraIndex = Math.min(Math.max(idx, 0), ERAS.length - 1);
                    updateEraUI(currentEraIndex);
                    addOverlaysForCurrentEra(overlays);
                }
            });

            toggleOverlays.addEventListener('change', () => {
                const shouldShow = toggleOverlays.checked;
                overlayLayers.forEach((layer) => {
                    if (!layer) return;
                    const isOnMap = map.hasLayer(layer);
                    if (shouldShow && !isOnMap) layer.addTo(map);
                    if (!shouldShow && isOnMap) map.removeLayer(layer);
                });
                updateOverlayMeta();
            });

            overlayOpacity.addEventListener('input', (e) => {
                const v = parseFloat(e.target.value);
                if (Number.isNaN(v)) return;
                opacityVal.textContent = v.toFixed(2);
                overlayLayers.forEach((layer) => {
                    if (layer.setOpacity) layer.setOpacity(v);
                });
            });

            const ROT_STEP = 5;
            const btnLeft = document.getElementById('rotLeft');
            const btnRight = document.getElementById('rotRight');

            function rotateAll(deltaDeg) {
                overlayLayers.forEach((layer) => {
                    if (!layer || !map.hasLayer(layer)) return;
                    // bevorzugt API von leaflet-distortableimage
                    if (typeof layer.setRotation === 'function') {
                        const cur = layer.options && layer.options.rotation ? layer.options.rotation : 0;
                        layer.setRotation(cur + deltaDeg);
                        layer.options.rotation = (cur + deltaDeg);
                    } else if (typeof layer.rotateBy === 'function') {
                        layer.rotateBy(deltaDeg);
                    }
                    // Fallbacks ignorieren – normale ImageOverlays werden nicht rotiert
                });
            }
            if (btnLeft) btnLeft.addEventListener('click', () => rotateAll(-ROT_STEP));
            if (btnRight) btnRight.addEventListener('click', () => rotateAll(ROT_STEP));

            function updateEraUI(idx) {
                eraNameOut.textContent = '· ' + (ERAS[idx] || '');
                eraIndexOut.textContent = (idx + 1) + '/' + ERAS.length;
            }
        }
    </script>
</body>

</html>